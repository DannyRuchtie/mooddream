"use strict";exports.id=767,exports.ids=[767],exports.modules={2574:(a,b,c)=>{c.d(b,{V:()=>d});function d(a,b,c){let d=(a>>24&255)/255;b[c++]=(255&a)/255*d,b[c++]=(a>>8&255)/255*d,b[c++]=(a>>16&255)/255*d,b[c++]=d}},7575:(a,b,c)=>{var d=c(45753);class e{constructor(a){this._renderer=a}push(a,b,c){this._renderer.renderPipes.batch.break(c),c.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:b,filterEffect:a})}pop(a,b,c){this._renderer.renderPipes.batch.break(c),c.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(a){"pushFilter"===a.action?this._renderer.filter.push(a):"popFilter"===a.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}e.extension={type:[d.Ag.WebGLPipes,d.Ag.WebGPUPipes,d.Ag.CanvasPipes],name:"filter"};var f=c(15104),g=c(5086),h=c(43984),i="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class j extends h.d{constructor(){super({gpuProgram:g.B.from({vertex:{source:i,entryPoint:"mainVertex"},fragment:{source:i,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:f.M.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}var k=c(48419),l=c(19979),m=c(94741),n=c(87796),o=c(61487),p=c(29695),q=c(11489),r=c(87790);let s=new k.u;var t=c(87818);let u=new m.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class v{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new r.c,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class w{constructor(a){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new n.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new l.T({}),this.renderer=a}get activeBackTexture(){return this._activeFilterData?.backTexture}push(a){let b=this.renderer,c=a.filterEffect.filters,d=this._pushFilterData();d.skip=!1,d.filters=c,d.container=a.container,d.outputRenderSurface=b.renderTarget.renderSurface;let e=b.renderTarget.renderTarget.colorTexture.source,f=e.resolution,g=e.antialias;if(c.every(a=>!a.enabled)){d.skip=!0;return}let h=d.bounds;if(this._calculateFilterArea(a,h),this._calculateFilterBounds(d,b.renderTarget.rootViewPort,g,f,1),d.skip)return;let i=this._getPreviousFilterData(),j=this._findFilterResolution(f),k=0,l=0;i&&(k=i.bounds.minX,l=i.bounds.minY),this._calculateGlobalFrame(d,k,l,j,e.width,e.height),this._setupFilterTextures(d,h,b,i)}generateFilteredTexture({texture:a,filters:b}){let c=this._pushFilterData();this._activeFilterData=c,c.skip=!1,c.filters=b;let d=a.source,e=d.resolution,f=d.antialias;if(b.every(a=>!a.enabled))return c.skip=!0,a;let g=c.bounds;if(g.addRect(a.frame),this._calculateFilterBounds(c,g.rectangle,f,e,0),c.skip)return a;this._calculateGlobalFrame(c,0,0,e,d.width,d.height),c.outputRenderSurface=p.W.getOptimalTexture(g.width,g.height,c.resolution,c.antialias),c.backTexture=o.g.EMPTY,c.inputTexture=a,this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(c,!0);let h=c.outputRenderSurface;return h.source.alphaMode="premultiplied-alpha",h}pop(){let a=this.renderer,b=this._popFilterData();b.skip||(a.globalUniforms.pop(),a.renderTarget.finishRenderPass(),this._activeFilterData=b,this._applyFiltersToTexture(b,!1),b.blendRequired&&p.W.returnTexture(b.backTexture),p.W.returnTexture(b.inputTexture))}getBackTexture(a,b,c){let d=a.colorTexture.source._resolution,e=p.W.getOptimalTexture(b.width,b.height,d,!1),f=b.minX,g=b.minY;c&&(f-=c.minX,g-=c.minY),f=Math.floor(f*d),g=Math.floor(g*d);let h=Math.ceil(b.width*d),i=Math.ceil(b.height*d);return this.renderer.renderTarget.copyToTexture(a,e,{x:f,y:g},{width:h,height:i},{x:0,y:0}),e}applyFilter(a,b,c,d){let e=this.renderer,f=this._activeFilterData,g=f.outputRenderSurface===c,h=e.renderTarget.rootRenderTarget.colorTexture.source._resolution,i=this._findFilterResolution(h),j=0,k=0;if(g){let a=this._findPreviousFilterOffset();j=a.x,k=a.y}this._updateFilterUniforms(b,c,f,j,k,i,g,d);let l=a.enabled?a:this._getPassthroughFilter();this._setupBindGroupsAndRender(l,b,e)}calculateSpriteMatrix(a,b){let c=this._activeFilterData,d=a.set(c.inputTexture._source.width,0,0,c.inputTexture._source.height,c.bounds.minX,c.bounds.minY),e=b.worldTransform.copyTo(k.u.shared),f=b.renderGroup||b.parentRenderGroup;return f&&f.cacheToLocalTransform&&e.prepend(f.cacheToLocalTransform),e.invert(),d.prepend(e),d.scale(1/b.texture.orig.width,1/b.texture.orig.height),d.translate(b.anchor.x,b.anchor.y),d}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new j),this._passthroughFilter}_setupBindGroupsAndRender(a,b,c){if(c.renderPipes.uniformBatch){let a=c.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(a,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(b.source,1),this._globalFilterBindGroup.setResource(b.source.style,2),a.groups[0]=this._globalFilterBindGroup,c.encoder.draw({geometry:u,shader:a,state:a._state,topology:"triangle-list"}),c.type===q.W.WEBGL&&c.renderTarget.finishRenderPass()}_setupFilterTextures(a,b,c,d){if(a.backTexture=o.g.EMPTY,a.inputTexture=p.W.getOptimalTexture(b.width,b.height,a.resolution,a.antialias),a.blendRequired){c.renderTarget.finishRenderPass();let e=c.renderTarget.getRenderTarget(a.outputRenderSurface);a.backTexture=this.getBackTexture(e,b,d?.bounds)}c.renderTarget.bind(a.inputTexture,!0),c.globalUniforms.push({offset:b})}_calculateGlobalFrame(a,b,c,d,e,f){let g=a.globalFrame;g.x=b*d,g.y=c*d,g.width=e*d,g.height=f*d}_updateFilterUniforms(a,b,c,d,e,f,g,h){let i=this._filterGlobalUniforms.uniforms,j=i.uOutputFrame,k=i.uInputSize,l=i.uInputPixel,m=i.uInputClamp,n=i.uGlobalFrame,p=i.uOutputTexture;g?(j[0]=c.bounds.minX-d,j[1]=c.bounds.minY-e):(j[0]=0,j[1]=0),j[2]=a.frame.width,j[3]=a.frame.height,k[0]=a.source.width,k[1]=a.source.height,k[2]=1/k[0],k[3]=1/k[1],l[0]=a.source.pixelWidth,l[1]=a.source.pixelHeight,l[2]=1/l[0],l[3]=1/l[1],m[0]=.5*l[2],m[1]=.5*l[3],m[2]=a.frame.width*k[2]-.5*l[2],m[3]=a.frame.height*k[3]-.5*l[3];let q=this.renderer.renderTarget.rootRenderTarget.colorTexture;n[0]=d*f,n[1]=e*f,n[2]=q.source.width*f,n[3]=q.source.height*f,b instanceof o.g&&(b.source.resource=null);let r=this.renderer.renderTarget.getRenderTarget(b);this.renderer.renderTarget.bind(b,!!h),b instanceof o.g?(p[0]=b.frame.width,p[1]=b.frame.height):(p[0]=r.width,p[1]=r.height),p[2]=r.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(a){let b=this._filterStackIndex-1;for(;b>0&&this._filterStack[b].skip;)--b;return b>0&&this._filterStack[b].inputTexture?this._filterStack[b].inputTexture.source._resolution:a}_findPreviousFilterOffset(){let a=0,b=0,c=this._filterStackIndex;for(;c>0;){c--;let d=this._filterStack[c];if(!d.skip){a=d.bounds.minX,b=d.bounds.minY;break}}return{x:a,y:b}}_calculateFilterArea(a,b){if(a.renderables?!function(a,b){b.clear();let c=b.matrix;for(let c=0;c<a.length;c++){let d=a[c];if(d.globalDisplayStatus<7)continue;let e=d.renderGroup??d.parentRenderGroup;e?.isCachedAsTexture?b.matrix=s.copyFrom(e.textureOffsetInverseTransform).append(d.worldTransform):e?._parentCacheAsTextureRenderGroup?b.matrix=s.copyFrom(e._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(d.groupTransform):b.matrix=d.worldTransform,b.addBounds(d.bounds)}b.matrix=c}(a.renderables,b):a.filterEffect.filterArea?(b.clear(),b.addRect(a.filterEffect.filterArea),b.applyMatrix(a.container.worldTransform)):a.container.getFastGlobalBounds(!0,b),a.container){let c=(a.container.renderGroup||a.container.parentRenderGroup).cacheToLocalTransform;c&&b.applyMatrix(c)}}_applyFiltersToTexture(a,b){let c=a.inputTexture,d=a.bounds,e=a.filters,f=a.firstEnabledIndex,g=a.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(c.source.style,2),this._globalFilterBindGroup.setResource(a.backTexture.source,3),f===g)e[f].apply(this,c,a.outputRenderSurface,b);else{let c=a.inputTexture,h=p.W.getOptimalTexture(d.width,d.height,c.source._resolution,!1),i=h;for(let a=f;a<g;a++){let b=e[a];if(!b.enabled)continue;b.apply(this,c,i,!0);let d=c;c=i,i=d}e[g].apply(this,c,a.outputRenderSurface,b),p.W.returnTexture(h)}}_calculateFilterBounds(a,b,c,d,e){let f=this.renderer,g=a.bounds,h=a.filters,i=1/0,j=0,k=!0,l=!1,m=!1,n=!0,o=-1,p=-1;for(let a=0;a<h.length;a++){let b=h[a];if(b.enabled){if(-1===o&&(o=a),p=a,i=Math.min(i,"inherit"===b.resolution?d:b.resolution),j+=b.padding,"off"===b.antialias?k=!1:"inherit"===b.antialias&&k&&(k=c),b.clipToViewport||(n=!1),!(b.compatibleRenderers&f.type)){m=!1;break}if(b.blendRequired&&!(f.backBuffer?.useBackBuffer??!0)){(0,t.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),m=!1;break}m=!0,l||(l=b.blendRequired)}}if(!m||(n&&g.fitBounds(0,b.width/d,0,b.height/d),g.scale(i).ceil().scale(1/i).pad((0|j)*e),!g.isPositive)){a.skip=!0;return}a.antialias=k,a.resolution=i,a.blendRequired=l,a.firstEnabledIndex=o,a.lastEnabledIndex=p}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let a,b=this._filterStackIndex-1;for(;b>0&&(b--,(a=this._filterStack[b]).skip););return a}_pushFilterData(){let a=this._filterStack[this._filterStackIndex];return a||(a=this._filterStack[this._filterStackIndex]=new v),this._filterStackIndex++,a}}w.extension={type:[d.Ag.WebGLSystem,d.Ag.WebGPUSystem],name:"filter"},d.XO.add(w),d.XO.add(e)},14333:(a,b,c)=>{c.d(b,{Ls:()=>d,_Q:()=>e,mA:()=>f});let d={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},e={...d,vertex:{...d.vertex,header:d.vertex.header.replace("group(1)","group(2)")}},f={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}}},17116:(a,b,c)=>{var d=c(45753);class e{execute(a,b){let c=a.state,d=a.renderer,e=b.shader||a.defaultShader;e.resources.uTexture=b.texture._source,e.resources.uniforms=a.localUniforms;let f=d.gl,g=a.getBuffers(b);d.shader.bind(e),d.state.set(c),d.geometry.bind(g.geometry,e.glProgram);let h=2===g.geometry.indexBuffer.data.BYTES_PER_ELEMENT?f.UNSIGNED_SHORT:f.UNSIGNED_INT;f.drawElements(f.TRIANGLES,6*b.particleChildren.length,h,0)}}var f=c(48419),g=c(87796),h=c(105),i=c(83305),j=c(2574),k=c(16183),l=c(43362),m=c(94741),n=c(96156),o=c(67834);function p(a,b=null){let c=6*a;if(c>65535?b||(b=new Uint32Array(c)):b||(b=new Uint16Array(c)),b.length!==c)throw Error(`Out buffer length is incorrect, got ${b.length} and expected ${c}`);for(let a=0,d=0;a<c;a+=6,d+=4)b[a+0]=d+0,b[a+1]=d+1,b[a+2]=d+2,b[a+3]=d+0,b[a+4]=d+2,b[a+5]=d+3;return b}function q(a,b){let c=[];c.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);let d=0;for(let e in a){let f=a[e];b===f.dynamic&&(c.push(`offset = index + ${d}`),c.push(f.code),d+=(0,n.m)(f.format).stride/4)}return c.push(`
            index += stride * 4;
        }
    `),c.unshift(`
        var stride = ${d};
    `),Function("ps","f32v","u32v",c.join("\n"))}class r{constructor(a){this._size=0,this._generateParticleUpdateCache={};const b=this._size=a.size??1e3,c=a.properties;let d=0,e=0;for(const a in c){const b=c[a],f=(0,n.m)(b.format);b.dynamic?e+=f.stride:d+=f.stride}this._dynamicStride=e/4,this._staticStride=d/4,this.staticAttributeBuffer=new o.u(4*b*d),this.dynamicAttributeBuffer=new o.u(4*b*e),this.indexBuffer=p(b);const f=new m.V;let g=0,h=0;for(const a in this._staticBuffer=new k.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:l.S.VERTEX|l.S.COPY_DST}),this._dynamicBuffer=new k.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:l.S.VERTEX|l.S.COPY_DST}),c){const b=c[a],d=(0,n.m)(b.format);b.dynamic?(f.addAttribute(b.attributeName,{buffer:this._dynamicBuffer,stride:4*this._dynamicStride,offset:4*g,format:b.format}),g+=d.size):(f.addAttribute(b.attributeName,{buffer:this._staticBuffer,stride:4*this._staticStride,offset:4*h,format:b.format}),h+=d.size)}f.addIndex(this.indexBuffer);const i=this.getParticleUpdate(c);this._dynamicUpload=i.dynamicUpdate,this._staticUpload=i.staticUpdate,this.geometry=f}getParticleUpdate(a){let b=function(a){let b=[];for(let c in a){let d=a[c];b.push(c,d.code,d.dynamic?"d":"s")}return b.join("_")}(a);return this._generateParticleUpdateCache[b]||(this._generateParticleUpdateCache[b]=this.generateParticleUpdate(a)),this._generateParticleUpdateCache[b]}generateParticleUpdate(a){return{dynamicUpdate:q(a,!0),staticUpdate:q(a,!1)}}update(a,b){a.length>this._size&&(b=!0,this._size=Math.max(a.length,1.5*this._size|0),this.staticAttributeBuffer=new o.u(this._size*this._staticStride*16),this.dynamicAttributeBuffer=new o.u(this._size*this._dynamicStride*16),this.indexBuffer=p(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));let c=this.dynamicAttributeBuffer;if(this._dynamicUpload(a,c.float32View,c.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,a.length*this._dynamicStride*4,!0),b){let b=this.staticAttributeBuffer;this._staticUpload(a,b.float32View,b.uint32View),this._staticBuffer.setDataWithSize(b.float32View,a.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}var s=c(66242),t=c(15104),u=c(5086),v=c(86233),w=c(61487),x=c(80424),y="\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class z extends v.M{constructor(){super({glProgram:t.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:u.B.from({fragment:{source:y,entryPoint:"mainFragment"},vertex:{source:y,entryPoint:"mainVertex"}}),resources:{uTexture:w.g.WHITE.source,uSampler:new x.n({}),uniforms:{uTranslationMatrix:{value:new f.u,type:"mat3x3<f32>"},uColor:{value:new s.Q(0xffffff),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class A{constructor(a,b){this.state=i.U.for2d(),this.localUniforms=new g.k({uTranslationMatrix:{value:new f.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=a,this.adaptor=b,this.defaultShader=new z,this.state=i.U.for2d()}validateRenderable(a){return!1}addRenderable(a,b){this.renderer.renderPipes.batch.break(b),b.add(a)}getBuffers(a){return a._gpuData[this.renderer.uid]||this._initBuffer(a)}_initBuffer(a){return a._gpuData[this.renderer.uid]=new r({size:a.particleChildren.length,properties:a._properties}),a._gpuData[this.renderer.uid]}updateRenderable(a){}execute(a){let b=a.particleChildren;if(0===b.length)return;let c=this.renderer,d=this.getBuffers(a);a.texture||(a.texture=b[0].texture);let e=this.state;d.update(b,a._childrenDirty),a._childrenDirty=!1,e.blendMode=(0,h.i)(a.blendMode,a.texture._source);let f=this.localUniforms.uniforms,g=f.uTranslationMatrix;a.worldTransform.copyTo(g),g.prepend(c.globalUniforms.globalUniformData.projectionMatrix),f.uResolution=c.globalUniforms.globalUniformData.resolution,f.uRound=c._roundPixels|a._roundPixels,(0,j.V)(a.groupColorAlpha,f.uColor,0),this.adaptor.execute(this,a)}destroy(){this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class B extends A{constructor(a){super(a,new e)}}B.extension={type:[d.Ag.WebGLPipes],name:"particle"};class C{execute(a,b){let c=a.renderer,d=b.shader||a.defaultShader;d.groups[0]=c.renderPipes.uniformBatch.getUniformBindGroup(a.localUniforms,!0),d.groups[1]=c.texture.getTextureBindGroup(b.texture);let e=a.state,f=a.getBuffers(b);c.encoder.draw({geometry:f.geometry,shader:b.shader||a.defaultShader,state:e,size:6*b.particleChildren.length})}}class D extends A{constructor(a){super(a,new C)}}D.extension={type:[d.Ag.WebGPUPipes],name:"particle"},d.XO.add(B),d.XO.add(D)},22724:(a,b,c)=>{c.d(b,{K:()=>d});class d{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){}}},27644:(a,b,c)=>{c.d(b,{U:()=>d});class d{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(a){this._topology=a}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(a){this.texture!==a&&(this.texture=a,this._textureMatrixUpdateId=-1)}get uvs(){let a=this.geometry.getBuffer("aUV"),b=a.data,c=b,d=this.texture.textureMatrix;return d.isSimple||(c=this._transformedUvs,(this._textureMatrixUpdateId!==d._updateID||this._uvUpdateId!==a._updateID)&&((!c||c.length<b.length)&&(c=this._transformedUvs=new Float32Array(b.length)),this._textureMatrixUpdateId=d._updateID,this._uvUpdateId=a._updateID,d.multiplyUvs(b,c))),c}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},34660:(a,b,c)=>{c.d(b,{M:()=>f});var d=c(29695);let e=new(c(87790)).c;function f(a,b,c,f){e.minX=0,e.minY=0,e.maxX=a.width/f|0,e.maxY=a.height/f|0;let g=d.W.getOptimalTexture(e.width,e.height,f,!1);return g.source.uploadMethodId="image",g.source.resource=a,g.source.alphaMode="premultiply-alpha-on-upload",g.frame.width=b/f,g.frame.height=c/f,g.source.emit("update",g.source),g.updateUvs(),g}},39604:(a,b,c)=>{var d=c(45753);class e{static init(a){Object.defineProperty(this,"resizeTo",{configurable:!0,set(a){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=a,a&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{let a,b;if(this._resizeTo){if(this._cancelResize(),this._resizeTo===globalThis.window)a=globalThis.innerWidth,b=globalThis.innerHeight;else{let{clientWidth:c,clientHeight:d}=this._resizeTo;a=c,b=d}this.renderer.resize(a,b),this.render()}},this._resizeId=null,this._resizeTo=null,this.resizeTo=a.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}e.extension=d.Ag.Application;var f=c(61328),g=c(26632);class h{static init(a){a=Object.assign({autoStart:!0,sharedTicker:!1},a),Object.defineProperty(this,"ticker",{configurable:!0,set(a){this._ticker&&this._ticker.remove(this.render,this),this._ticker=a,a&&a.add(this.render,this,f.d.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=a.sharedTicker?g.R.shared:new g.R,a.autoStart&&this.start()}static destroy(){if(this._ticker){let a=this._ticker;this.ticker=null,a.destroy()}}}h.extension=d.Ag.Application,d.XO.add(e),d.XO.add(h)},47336:(a,b,c)=>{let d,e;var f=c(45753),g=c(1157),h=c(81618),i=c(88066),j=c(48419),k=c(95420),l=c(80225),m=c(79862),n=c(35563),o=c(34298),p=c(86233),q=c(87796);let r={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:`
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},s={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:`
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},t={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `}},u={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `}};class v extends p.M{constructor(a){const b=new q.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new j.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});d??(d=(0,k.v)({name:"sdf-shader",bits:[l.F,(0,m._)(a),r,t,n.b]})),e??(e=(0,k.I)({name:"sdf-shader",bits:[l.a,(0,m.P)(a),s,u,n.m]})),super({glProgram:e,gpuProgram:d,resources:{localUniforms:b,batchSamplers:(0,o.n)(a)}})}}var w=c(89949),x=c(88281);class y extends h.A{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class z{constructor(a){this._renderer=a}validateRenderable(a){let b=this._getGpuBitmapText(a);return this._renderer.renderPipes.graphics.validateRenderable(b)}addRenderable(a,b){let c=this._getGpuBitmapText(a);A(a,c),a._didTextUpdate&&(a._didTextUpdate=!1,this._updateContext(a,c)),this._renderer.renderPipes.graphics.addRenderable(c,b),c.context.customShader&&this._updateDistanceField(a)}updateRenderable(a){let b=this._getGpuBitmapText(a);A(a,b),this._renderer.renderPipes.graphics.updateRenderable(b),b.context.customShader&&this._updateDistanceField(a)}_updateContext(a,b){let{context:c}=b,d=w.c.getFont(a.text,a._style);c.clear(),"none"===d.distanceField.type||c.customShader||(c.customShader=new v(this._renderer.limits.maxBatchableTextures));let e=i.P.graphemeSegmenter(a.text),f=a._style,g=d.baseLineOffset,h=(0,x.Z)(e,f,d,!0),j=f.padding,k=h.scale,l=h.width,m=h.height+h.offsetY;f._stroke&&(l+=f._stroke.width/k,m+=f._stroke.width/k),c.translate(-a._anchor._x*l-j,-a._anchor._y*m-j).scale(k,k);let n=d.applyFillAsTint?f._fill.color:0xffffff,o=d.fontMetrics.fontSize,p=d.lineHeight;f.lineHeight&&(o=f.fontSize/k,p=f.lineHeight/k);let q=(p-o)/2;q-d.baseLineOffset<0&&(q=0);for(let a=0;a<h.lines.length;a++){let b=h.lines[a];for(let a=0;a<b.charPositions.length;a++){let e=b.chars[a],f=d.chars[e];if(f?.texture){let d=f.texture;c.texture(d,n||"black",Math.round(b.charPositions[a]+f.xOffset),Math.round(g+f.yOffset+q),d.orig.width,d.orig.height)}}g+=p}}_getGpuBitmapText(a){return a._gpuData[this._renderer.uid]||this.initGpuText(a)}initGpuText(a){let b=new y;return a._gpuData[this._renderer.uid]=b,this._updateContext(a,b),b}_updateDistanceField(a){let b=this._getGpuBitmapText(a).context,c=a._style.fontFamily,d=g.l.get(`${c}-bitmap`),{a:e,b:f,c:h,d:i}=a.groupTransform,j=(Math.abs(Math.sqrt(e*e+f*f))+Math.abs(Math.sqrt(h*h+i*i)))/2,k=d.baseRenderedFontSize/a._style.fontSize,l=j*d.distanceField.range*(1/k);b.customShader.resources.localUniforms.uniforms.uDistance=l}destroy(){this._renderer=null}}function A(a,b){b.groupTransform=a.groupTransform,b.groupColorAlpha=a.groupColorAlpha,b.groupColor=a.groupColor,b.groupBlendMode=a.groupBlendMode,b.globalDisplayStatus=a.globalDisplayStatus,b.groupTransform=a.groupTransform,b.localDisplayStatus=a.localDisplayStatus,b.groupAlpha=a.groupAlpha,b._roundPixels=a._roundPixels}z.extension={type:[f.Ag.WebGLPipes,f.Ag.WebGPUPipes,f.Ag.CanvasPipes],name:"bitmapText"},f.XO.add(z)},51647:(a,b,c)=>{let d;var e=c(45753),f=c(61487),g=c(59084),h=c(22724);class i extends h.K{constructor(a){super(),this.generatingTexture=!1,this.currentKey="--",this._renderer=a,a.runners.resolutionChange.add(this)}resolutionChange(){let a=this.renderable;a._autoResolution&&a.onViewUpdate()}destroy(){let{htmlText:a}=this._renderer;null===a.getReferenceCount(this.currentKey)?a.returnTexturePromise(this.texturePromise):a.decreaseReferenceCount(this.currentKey),this._renderer.runners.resolutionChange.remove(this),this.texturePromise=null,this._renderer=null}}class j{constructor(a){this._renderer=a}validateRenderable(a){let b=this._getGpuText(a),c=a.styleKey;return b.currentKey!==c}addRenderable(a,b){let c=this._getGpuText(a);if(a._didTextUpdate){let b=a._autoResolution?this._renderer.resolution:a.resolution;(c.currentKey!==a.styleKey||a.resolution!==b)&&this._updateGpuText(a).catch(a=>{console.error(a)}),a._didTextUpdate=!1,(0,g.s)(c,a)}this._renderer.renderPipes.batch.addToBatch(c,b)}updateRenderable(a){let b=this._getGpuText(a);b._batcher.updateElement(b)}async _updateGpuText(a){a._didTextUpdate=!1;let b=this._getGpuText(a);if(b.generatingTexture)return;let c=b.texturePromise;b.texturePromise=null,b.generatingTexture=!0,a._resolution=a._autoResolution?this._renderer.resolution:a.resolution;let d=this._renderer.htmlText.getTexturePromise(a);c&&(d=d.finally(()=>{this._renderer.htmlText.decreaseReferenceCount(b.currentKey),this._renderer.htmlText.returnTexturePromise(c)})),b.texturePromise=d,b.currentKey=a.styleKey,b.texture=await d;let e=a.renderGroup||a.parentRenderGroup;e&&(e.structureDidChange=!0),b.generatingTexture=!1,(0,g.s)(b,a)}_getGpuText(a){return a._gpuData[this._renderer.uid]||this.initGpuText(a)}initGpuText(a){let b=new i(this._renderer);return b.renderable=a,b.transform=a.groupTransform,b.texture=f.g.EMPTY,b.bounds={minX:0,maxX:1,minY:0,maxY:0},b.roundPixels=this._renderer._roundPixels|a._roundPixels,a._resolution=a._autoResolution?this._renderer.resolution:a.resolution,a._gpuData[this._renderer.uid]=b,b}destroy(){this._renderer=null}}j.extension={type:[e.Ag.WebGLPipes,e.Ag.WebGPUPipes,e.Ag.CanvasPipes],name:"htmlText"};var k=c(92714),l=c(29695),m=c(11489),n=c(43274),o=c(87818),p=c(6672),q=c(34660);let r="http://www.w3.org/2000/svg",s="http://www.w3.org/1999/xhtml";class t{constructor(){this.svgRoot=document.createElementNS(r,"svg"),this.foreignObject=document.createElementNS(r,"foreignObject"),this.domElement=document.createElementNS(s,"div"),this.styleElement=document.createElementNS(s,"style");const{foreignObject:a,svgRoot:b,styleElement:c,domElement:d}=this;a.setAttribute("width","10000"),a.setAttribute("height","10000"),a.style.overflow="hidden",b.appendChild(a),a.appendChild(c),a.appendChild(d),this.image=n.e.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}var u=c(1157);async function v(a){let b=await n.e.get().fetch(a),c=await b.blob(),d=new FileReader;return await new Promise((a,b)=>{d.onloadend=()=>a(d.result),d.onerror=b,d.readAsDataURL(c)})}async function w(a,b){let c=await v(b);return`@font-face {
        font-family: "${a.fontFamily}";
        font-weight: ${a.fontWeight};
        font-style: ${a.fontStyle};
        src: url('${c}');
    }`}let x=new Map;async function y(a){let b=a.filter(a=>u.l.has(`${a}-and-url`)).map(a=>{if(!x.has(a)){let{entries:b}=u.l.get(`${a}-and-url`),c=[];b.forEach(b=>{let d=b.url,e=b.faces.map(a=>({weight:a.weight,style:a.style}));c.push(...e.map(b=>w({fontWeight:b.weight,fontStyle:b.style,fontFamily:a},d)))}),x.set(a,Promise.all(c).then(a=>a.join("\n")))}return x.get(a)});return(await Promise.all(b)).join("\n")}class z{constructor(a){this._activeTextures={},this._renderer=a,this._createCanvas=a.type===m.W.WEBGPU}getTexture(a){return this.getTexturePromise(a)}getManagedTexture(a){let b=a.styleKey;if(this._activeTextures[b])return this._increaseReferenceCount(b),this._activeTextures[b].promise;let c=this._buildTexturePromise(a).then(a=>(this._activeTextures[b].texture=a,a));return this._activeTextures[b]={texture:null,promise:c,usageCount:1},c}getReferenceCount(a){return this._activeTextures[a]?.usageCount??null}_increaseReferenceCount(a){this._activeTextures[a].usageCount++}decreaseReferenceCount(a){let b=this._activeTextures[a];b&&(b.usageCount--,0===b.usageCount&&(b.texture?this._cleanUp(b.texture):b.promise.then(a=>{b.texture=a,this._cleanUp(b.texture)}).catch(()=>{(0,o.R)("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[a]=null))}getTexturePromise(a){return this._buildTexturePromise(a)}async _buildTexturePromise(a){var b;let c,{text:e,style:f,resolution:g,textureStyle:h}=a,i=p.Z.get(t),j=function(a,b){let c=b.fontFamily,d=[],e={},f=a.match(/font-family:([^;"\s]+)/g);function g(a){e[a]||(d.push(a),e[a]=!0)}if(Array.isArray(c))for(let a=0;a<c.length;a++)g(c[a]);else g(c);for(let a in f&&f.forEach(a=>{g(a.split(":")[1].trim())}),b.tagStyles)g(b.tagStyles[a].fontFamily);return d}(e,f),l=await y(j),m=function(a,b,c,e){e||(e=d||(d=new t));let{domElement:f,styleElement:g,svgRoot:h}=e;f.innerHTML=`<style>${b.cssStyle};</style><div style='padding:0'>${a}</div>`,f.setAttribute("style","transform-origin: top left; display: inline-block"),c&&(g.textContent=c),document.body.appendChild(h);let i=f.getBoundingClientRect();h.remove();let j=2*b.padding;return{width:i.width-j,height:i.height-j}}(e,f,l,i),o=Math.ceil(Math.ceil(Math.max(1,m.width)+2*f.padding)*g),r=Math.ceil(Math.ceil(Math.max(1,m.height)+2*f.padding)*g),s=i.image;s.width=(0|o)+2,s.height=(0|r)+2;let u=function(a,b,c,d,e){let{domElement:f,styleElement:g,svgRoot:h}=e;f.innerHTML=`<style>${b.cssStyle}</style><div style='padding:0;'>${a}</div>`,f.setAttribute("style",`transform: scale(${c});transform-origin: top left; display: inline-block`),g.textContent=d;let{width:i,height:j}=e.image;return h.setAttribute("width",i.toString()),h.setAttribute("height",j.toString()),new XMLSerializer().serializeToString(h)}(e,f,g,l,i);await (b=function(){let{userAgent:a}=n.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(a)}()&&j.length>0,new Promise(async a=>{b&&await new Promise(a=>setTimeout(a,100)),s.onload=()=>{a()},s.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(u)}`,s.crossOrigin="anonymous"})),this._createCanvas&&(c=function(a,b){let c=k.N.getOptimalCanvasAndContext(a.width,a.height,b),{context:d}=c;return d.clearRect(0,0,a.width,a.height),d.drawImage(a,0,0),c}(s,g));let v=(0,q.M)(c?c.canvas:s,s.width-2,s.height-2,g);return h&&(v.source.style=h),this._createCanvas&&(this._renderer.texture.initSource(v.source),k.N.returnCanvasAndContext(c)),p.Z.return(i),v}returnTexturePromise(a){a.then(a=>{this._cleanUp(a)}).catch(()=>{(0,o.R)("HTMLTextSystem: Failed to clean texture")})}_cleanUp(a){l.W.returnTexture(a,!0),a.source.resource=null,a.source.uploadMethodId="unknown"}destroy(){for(let a in this._renderer=null,this._activeTextures)this._activeTextures[a]&&this.returnTexturePromise(this._activeTextures[a].promise);this._activeTextures=null}}z.extension={type:[e.Ag.WebGLSystem,e.Ag.WebGPUSystem,e.Ag.CanvasSystem],name:"htmlText"},e.XO.add(z),e.XO.add(j)},59084:(a,b,c)=>{c.d(b,{s:()=>e});var d=c(40786);function e(a,b){let{texture:c,bounds:e}=a,f=b._style._getFinalPadding();(0,d.y)(e,b._anchor,c);let g=b._anchor._x*f*2,h=b._anchor._y*f*2;e.minX-=f-g,e.minY-=f-h,e.maxX-=f-g,e.maxY-=f-h}},61918:(a,b,c)=>{let d,e;var f=c(45753),g=c(105),h=c(83305),i=c(11489),j=c(2574),k=c(27644),l=c(62802),m=c(48419),n=c(95420),o=c(14333),p=c(35563),q=c(86233),r=c(87796),s=c(61487);let t={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},u={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `}};class v extends q.M{constructor(){d??(d=(0,n.v)({name:"tiling-sprite-shader",bits:[o.Ls,t,p.b]})),e??(e=(0,n.I)({name:"tiling-sprite-shader",bits:[o.mA,u,p.m]})),super({glProgram:e,gpuProgram:d,resources:{localUniforms:new r.k({uTransformMatrix:{value:new m.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:new r.k({uMapCoord:{value:new m.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new m.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}}),uTexture:s.g.EMPTY.source,uSampler:s.g.EMPTY.source.style}})}updateUniforms(a,b,c,d,e,f){let g=this.resources.tilingUniforms,h=f.width,i=f.height,j=f.textureMatrix,k=g.uniforms.uTextureTransform;k.set(c.a*h/a,c.b*h/b,c.c*i/a,c.d*i/b,c.tx/a,c.ty/b),k.invert(),g.uniforms.uMapCoord=j.mapCoord,g.uniforms.uClampFrame=j.uClampFrame,g.uniforms.uClampOffset=j.uClampOffset,g.uniforms.uTextureTransform=k,g.uniforms.uSizeAnchor[0]=a,g.uniforms.uSizeAnchor[1]=b,g.uniforms.uSizeAnchor[2]=d,g.uniforms.uSizeAnchor[3]=e,f&&(this.resources.uTexture=f.source,this.resources.uSampler=f.source.style)}}class w extends l.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}let x=new w;class y{constructor(){this.canBatch=!0,this.geometry=new l.u({indices:x.indices.slice(),positions:x.positions.slice(),uvs:x.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class z{constructor(a){this._state=h.U.default2d,this._renderer=a}validateRenderable(a){let b=this._getTilingSpriteData(a),c=b.canBatch;this._updateCanBatch(a);let d=b.canBatch;if(d&&d===c){let{batchableMesh:c}=b;return!c._batcher.checkAndUpdateTexture(c,a.texture)}return c!==d}addRenderable(a,b){let c=this._renderer.renderPipes.batch;this._updateCanBatch(a);let d=this._getTilingSpriteData(a),{geometry:e,canBatch:f}=d;if(f){d.batchableMesh||(d.batchableMesh=new k.U);let f=d.batchableMesh;a.didViewUpdate&&(this._updateBatchableMesh(a),f.geometry=e,f.renderable=a,f.transform=a.groupTransform,f.setTexture(a._texture)),f.roundPixels=this._renderer._roundPixels|a._roundPixels,c.addToBatch(f,b)}else c.break(b),d.shader||(d.shader=new v),this.updateRenderable(a),b.add(a)}execute(a){let{shader:b}=this._getTilingSpriteData(a);b.groups[0]=this._renderer.globalUniforms.bindGroup;let c=b.resources.localUniforms.uniforms;c.uTransformMatrix=a.groupTransform,c.uRound=this._renderer._roundPixels|a._roundPixels,(0,j.V)(a.groupColorAlpha,c.uColor,0),this._state.blendMode=(0,g.i)(a.groupBlendMode,a.texture._source),this._renderer.encoder.draw({geometry:x,shader:b,state:this._state})}updateRenderable(a){let b=this._getTilingSpriteData(a),{canBatch:c}=b;if(c){let{batchableMesh:c}=b;a.didViewUpdate&&this._updateBatchableMesh(a),c._batcher.updateElement(c)}else if(a.didViewUpdate){let{shader:c}=b;c.updateUniforms(a.width,a.height,a._tileTransform.matrix,a.anchor.x,a.anchor.y,a.texture)}}_getTilingSpriteData(a){return a._gpuData[this._renderer.uid]||this._initTilingSpriteData(a)}_initTilingSpriteData(a){let b=new y;return b.renderable=a,a._gpuData[this._renderer.uid]=b,b}_updateBatchableMesh(a){var b,c;let d,e,f,g,h,i,j,k,{geometry:l}=this._getTilingSpriteData(a),n=a.texture.source.style;"repeat"!==n.addressMode&&(n.addressMode="repeat",n.update()),b=l.uvs,e=(d=a.texture).frame.width,f=d.frame.height,g=0,h=0,a.applyAnchorToTexture&&(g=a.anchor.x,h=a.anchor.y),b[0]=b[6]=-g,b[2]=b[4]=1-g,b[1]=b[3]=-h,b[5]=b[7]=1-h,(i=m.u.shared).copyFrom(a._tileTransform.matrix),i.tx/=a.width,i.ty/=a.height,i.invert(),i.scale(a.width/e,a.height/f),function(a,b,c,d){let e=0,f=a.length/2,g=d.a,h=d.b,i=d.c,j=d.d,k=d.tx,l=d.ty;for(c*=2;e<f;){let b=a[c],d=a[c+1];a[c]=g*b+i*d+k,a[c+1]=h*b+j*d+l,c+=2,e++}}(b,0,0,i),c=l.positions,j=a.anchor.x,k=a.anchor.y,c[0]=-j*a.width,c[1]=-k*a.height,c[2]=(1-j)*a.width,c[3]=-k*a.height,c[4]=(1-j)*a.width,c[5]=(1-k)*a.height,c[6]=-j*a.width,c[7]=(1-k)*a.height}destroy(){this._renderer=null}_updateCanBatch(a){let b=this._getTilingSpriteData(a),c=a.texture,d=!0;return this._renderer.type===i.W.WEBGL&&(d=this._renderer.context.supports.nonPowOf2wrapping),b.canBatch=c.textureMatrix.isSimple&&(d||c.source.isPowerOfTwo),b.canBatch}}z.extension={type:[f.Ag.WebGLPipes,f.Ag.WebGPUPipes,f.Ag.CanvasPipes],name:"tilingSprite"},f.XO.add(z)},62022:(a,b,c)=>{var d=c(45753),e=c(27644),f=c(71568),g=c(62802);let h=class a extends g.u{constructor(...a){super({});let b=a[0]??{};"number"==typeof b&&((0,f.t6)(f.lj,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),b={width:b,height:a[1],verticesX:a[2],verticesY:a[3]}),this.build(b)}build(b){b={...a.defaultOptions,...b},this.verticesX=this.verticesX??b.verticesX,this.verticesY=this.verticesY??b.verticesY,this.width=this.width??b.width,this.height=this.height??b.height;let c=this.verticesX*this.verticesY,d=[],e=[],f=[],g=this.verticesX-1,h=this.verticesY-1,i=this.width/g,j=this.height/h;for(let a=0;a<c;a++){let b=a%this.verticesX,c=a/this.verticesX|0;d.push(b*i,c*j),e.push(b/g,c/h)}let k=g*h;for(let a=0;a<k;a++){let b=a%g,c=a/g|0,d=c*this.verticesX+b,e=c*this.verticesX+b+1,h=(c+1)*this.verticesX+b,i=(c+1)*this.verticesX+b+1;f.push(d,e,h,e,i,h)}this.buffers[0].data=new Float32Array(d),this.buffers[1].data=new Float32Array(e),this.indexBuffer.data=new Uint32Array(f),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};h.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let i=h,j=class a extends i{constructor(b={}){b={...a.defaultOptions,...b},super({width:b.width,height:b.height,verticesX:4,verticesY:4}),this.update(b)}update(a){this.width=a.width??this.width,this.height=a.height??this.height,this._originalWidth=a.originalWidth??this._originalWidth,this._originalHeight=a.originalHeight??this._originalHeight,this._leftWidth=a.leftWidth??this._leftWidth,this._rightWidth=a.rightWidth??this._rightWidth,this._topHeight=a.topHeight??this._topHeight,this._bottomHeight=a.bottomHeight??this._bottomHeight,this._anchorX=a.anchor?.x,this._anchorY=a.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){let a=this.positions,{width:b,height:c,_leftWidth:d,_rightWidth:e,_topHeight:f,_bottomHeight:g,_anchorX:h,_anchorY:i}=this,j=d+e,k=f+g,l=Math.min(b>j?1:b/j,c>k?1:c/k),m=h*b,n=i*c;a[0]=a[8]=a[16]=a[24]=-m,a[2]=a[10]=a[18]=a[26]=d*l-m,a[4]=a[12]=a[20]=a[28]=b-e*l-m,a[6]=a[14]=a[22]=a[30]=b-m,a[1]=a[3]=a[5]=a[7]=-n,a[9]=a[11]=a[13]=a[15]=f*l-n,a[17]=a[19]=a[21]=a[23]=c-g*l-n,a[25]=a[27]=a[29]=a[31]=c-n,this.getBuffer("aPosition").update()}updateUvs(){let a=this.uvs;a[0]=a[8]=a[16]=a[24]=0,a[1]=a[3]=a[5]=a[7]=0,a[6]=a[14]=a[22]=a[30]=1,a[25]=a[27]=a[29]=a[31]=1;let b=1/this._originalWidth,c=1/this._originalHeight;a[2]=a[10]=a[18]=a[26]=b*this._leftWidth,a[9]=a[11]=a[13]=a[15]=c*this._topHeight,a[4]=a[12]=a[20]=a[28]=1-b*this._rightWidth,a[17]=a[19]=a[21]=a[23]=1-c*this._bottomHeight,this.getBuffer("aUV").update()}};j.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};class k extends e.U{constructor(){super(),this.geometry=new j}destroy(){this.geometry.destroy()}}class l{constructor(a){this._renderer=a}addRenderable(a,b){let c=this._getGpuSprite(a);a.didViewUpdate&&this._updateBatchableSprite(a,c),this._renderer.renderPipes.batch.addToBatch(c,b)}updateRenderable(a){let b=this._getGpuSprite(a);a.didViewUpdate&&this._updateBatchableSprite(a,b),b._batcher.updateElement(b)}validateRenderable(a){let b=this._getGpuSprite(a);return!b._batcher.checkAndUpdateTexture(b,a._texture)}_updateBatchableSprite(a,b){b.geometry.update(a),b.setTexture(a._texture)}_getGpuSprite(a){return a._gpuData[this._renderer.uid]||this._initGPUSprite(a)}_initGPUSprite(a){let b=a._gpuData[this._renderer.uid]=new k;return b.renderable=a,b.transform=a.groupTransform,b.texture=a._texture,b.roundPixels=this._renderer._roundPixels|a._roundPixels,a.didViewUpdate||this._updateBatchableSprite(a,b),b}destroy(){this._renderer=null}}l.extension={type:[d.Ag.WebGLPipes,d.Ag.WebGPUPipes,d.Ag.CanvasPipes],name:"nineSliceSprite"},d.XO.add(l)},62802:(a,b,c)=>{c.d(b,{u:()=>i});var d=c(16183),e=c(43362),f=c(94741),g=c(71568);let h=class a extends f.V{constructor(...b){let c=b[0]??{};c instanceof Float32Array&&((0,g.t6)(g.lj,"use new MeshGeometry({ positions, uvs, indices }) instead"),c={positions:c,uvs:b[1],indices:b[2]});const f=(c={...a.defaultOptions,...c}).positions||new Float32Array([0,0,1,0,1,1,0,1]);let h=c.uvs;h||(h=new Float32Array(c.positions?f.length:[0,0,1,0,1,1,0,1]));const i=c.indices||new Uint32Array([0,1,2,0,2,3]),j=c.shrinkBuffersToFit,k=new d.h({data:f,label:"attribute-mesh-positions",shrinkToFit:j,usage:e.S.VERTEX|e.S.COPY_DST});super({attributes:{aPosition:{buffer:k,format:"float32x2",stride:8,offset:0},aUV:{buffer:new d.h({data:h,label:"attribute-mesh-uvs",shrinkToFit:j,usage:e.S.VERTEX|e.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new d.h({data:i,label:"index-mesh-buffer",shrinkToFit:j,usage:e.S.INDEX|e.S.COPY_DST}),topology:c.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(a){this.attributes.aPosition.buffer.data=a}get uvs(){return this.attributes.aUV.buffer.data}set uvs(a){this.attributes.aUV.buffer.data=a}get indices(){return this.indexBuffer.data}set indices(a){this.indexBuffer.data=a}};h.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let i=h},78053:(a,b,c)=>{var d=c(45753),e=c(48419),f=c(19979),g=c(87796),h=c(105),i=c(2574),j=c(27644);class k{destroy(){}}class l{constructor(a,b){this.localUniforms=new g.k({uTransformMatrix:{value:new e.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new f.T({0:this.localUniforms}),this.renderer=a,this._adaptor=b,this._adaptor.init()}validateRenderable(a){let b=this._getMeshData(a),c=b.batched,d=a.batched;if(b.batched=d,c!==d)return!0;if(d){let c=a._geometry;if(c.indices.length!==b.indexSize||c.positions.length!==b.vertexSize)return b.indexSize=c.indices.length,b.vertexSize=c.positions.length,!0;let d=this._getBatchableMesh(a);return d.texture.uid!==a._texture.uid&&(d._textureMatrixUpdateId=-1),!d._batcher.checkAndUpdateTexture(d,a._texture)}return!1}addRenderable(a,b){let c=this.renderer.renderPipes.batch,d=this._getMeshData(a);if(a.didViewUpdate&&(d.indexSize=a._geometry.indices?.length,d.vertexSize=a._geometry.positions?.length),d.batched){let d=this._getBatchableMesh(a);d.setTexture(a._texture),d.geometry=a._geometry,c.addToBatch(d,b)}else c.break(b),b.add(a)}updateRenderable(a){if(a.batched){let b=this._getBatchableMesh(a);b.setTexture(a._texture),b.geometry=a._geometry,b._batcher.updateElement(b)}}execute(a){if(!a.isRenderable)return;a.state.blendMode=(0,h.i)(a.groupBlendMode,a.texture._source);let b=this.localUniforms;b.uniforms.uTransformMatrix=a.groupTransform,b.uniforms.uRound=this.renderer._roundPixels|a._roundPixels,b.update(),(0,i.V)(a.groupColorAlpha,b.uniforms.uColor,0),this._adaptor.execute(this,a)}_getMeshData(a){var b,c;return(b=a._gpuData)[c=this.renderer.uid]||(b[c]=new k),a._gpuData[this.renderer.uid].meshData||this._initMeshData(a)}_initMeshData(a){return a._gpuData[this.renderer.uid].meshData={batched:a.batched,indexSize:0,vertexSize:0},a._gpuData[this.renderer.uid].meshData}_getBatchableMesh(a){var b,c;return(b=a._gpuData)[c=this.renderer.uid]||(b[c]=new k),a._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(a)}_initBatchableMesh(a){let b=new j.U;return b.renderable=a,b.setTexture(a._texture),b.transform=a.groupTransform,b.roundPixels=this.renderer._roundPixels|a._roundPixels,a._gpuData[this.renderer.uid].batchableMesh=b,b}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}l.extension={type:[d.Ag.WebGLPipes,d.Ag.WebGPUPipes,d.Ag.CanvasPipes],name:"mesh"},d.XO.add(l)},94880:(a,b,c)=>{var d=c(45753),e=c(84195),f=c(83305),g=c(6672),h=c(2574),i=c(9848);class j{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(a=>{g.Z.return(a)}),this.batches.length=0}}class k{constructor(a,b){this.state=f.U.for2d(),this.renderer=a,this._adaptor=b,this.renderer.runners.contextChange.add(this)}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(a){let b=a.context,c=!!a._gpuData,d=this.renderer.graphicsContext.updateGpuContext(b);return!!d.isBatchable||c!==d.isBatchable}addRenderable(a,b){let c=this.renderer.graphicsContext.updateGpuContext(a.context);a.didViewUpdate&&this._rebuild(a),c.isBatchable?this._addToBatcher(a,b):(this.renderer.renderPipes.batch.break(b),b.add(a))}updateRenderable(a){let b=this._getGpuDataForRenderable(a).batches;for(let a=0;a<b.length;a++){let c=b[a];c._batcher.updateElement(c)}}execute(a){if(!a.isRenderable)return;let b=this.renderer,c=a.context;if(!b.graphicsContext.getGpuContext(c).batches.length)return;let d=c.customShader||this._adaptor.shader;this.state.blendMode=a.groupBlendMode;let e=d.resources.localUniforms.uniforms;e.uTransformMatrix=a.groupTransform,e.uRound=b._roundPixels|a._roundPixels,(0,h.V)(a.groupColorAlpha,e.uColor,0),this._adaptor.execute(this,a)}_rebuild(a){let b=this._getGpuDataForRenderable(a),c=this.renderer.graphicsContext.updateGpuContext(a.context);b.destroy(),c.isBatchable&&this._updateBatchesForRenderable(a,b)}_addToBatcher(a,b){let c=this.renderer.renderPipes.batch,d=this._getGpuDataForRenderable(a).batches;for(let a=0;a<d.length;a++){let e=d[a];c.addToBatch(e,b)}}_getGpuDataForRenderable(a){return a._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(a)}_initGpuDataForRenderable(a){let b=new j;return a._gpuData[this.renderer.uid]=b,b}_updateBatchesForRenderable(a,b){let c=a.context,d=this.renderer.graphicsContext.getGpuContext(c),e=this.renderer._roundPixels|a._roundPixels;b.batches=d.batches.map(b=>{let c=g.Z.get(i.G);return b.copyTo(c),c.renderable=a,c.roundPixels=e,c})}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}k.extension={type:[d.Ag.WebGLPipes,d.Ag.WebGPUPipes,d.Ag.CanvasPipes],name:"graphics"},d.XO.add(k),d.XO.add(e.GH)},97761:(a,b,c)=>{var d=c(45753),e=c(59084),f=c(22724);class g extends f.K{constructor(a){super(),this._renderer=a,a.runners.resolutionChange.add(this)}resolutionChange(){let a=this.renderable;a._autoResolution&&a.onViewUpdate()}destroy(){let{canvasText:a}=this._renderer;a.getReferenceCount(this.currentKey)>0?a.decreaseReferenceCount(this.currentKey):this.texture&&a.returnTexture(this.texture),this._renderer.runners.resolutionChange.remove(this),this._renderer=null}}class h{constructor(a){this._renderer=a}validateRenderable(a){let b=this._getGpuText(a),c=a.styleKey;return b.currentKey!==c||a._didTextUpdate}addRenderable(a,b){let c=this._getGpuText(a);if(a._didTextUpdate){let b=a._autoResolution?this._renderer.resolution:a.resolution;(c.currentKey!==a.styleKey||a.resolution!==b)&&this._updateGpuText(a),a._didTextUpdate=!1,(0,e.s)(c,a)}this._renderer.renderPipes.batch.addToBatch(c,b)}updateRenderable(a){let b=this._getGpuText(a);b._batcher.updateElement(b)}_updateGpuText(a){let b=this._getGpuText(a);b.texture&&this._renderer.canvasText.decreaseReferenceCount(b.currentKey),a._resolution=a._autoResolution?this._renderer.resolution:a.resolution,b.texture=this._renderer.canvasText.getManagedTexture(a),b.currentKey=a.styleKey}_getGpuText(a){return a._gpuData[this._renderer.uid]||this.initGpuText(a)}initGpuText(a){let b=new g(this._renderer);return b.currentKey="--",b.renderable=a,b.transform=a.groupTransform,b.bounds={minX:0,maxX:1,minY:0,maxY:0},b.roundPixels=this._renderer._roundPixels|a._roundPixels,a._gpuData[this._renderer.uid]=b,b}destroy(){this._renderer=null}}h.extension={type:[d.Ag.WebGLPipes,d.Ag.WebGPUPipes,d.Ag.CanvasPipes],name:"text"};var i=c(29695),j=c(80424),k=c(71568),l=c(54497),m=c(34660),n=c(66242),o=c(91546),p=c(92714),q=c(43274),r=c(92149);let s=null,t=null;function u(a,b,c){for(let d=0,e=4*c*b;d<b;++d,e+=4)if(0!==a[e+3])return!1;return!0}function v(a,b,c,d,e){let f=4*b;for(let b=d,g=d*f+4*c;b<=e;++b,g+=f)if(0!==a[g+3])return!1;return!0}var w=c(88066),x=c(60056),y=c(57266);let z=new o.M;class A{getCanvasAndContext(a){let{text:b,style:c,resolution:d=1}=a,e=c._getFinalPadding(),f=w.P.measureText(b||" ",c),g=Math.ceil(Math.ceil(Math.max(1,f.width)+2*e)*d),h=Math.ceil(Math.ceil(Math.max(1,f.height)+2*e)*d),i=p.N.getOptimalCanvasAndContext(g,h);this._renderTextToCanvas(b,c,e,d,i);let j=c.trim?function(...a){let b=a[0];b.canvas||(b={canvas:a[0],resolution:a[1]});let{canvas:c}=b,d=Math.min(b.resolution??1,1),e=b.width??c.width,f=b.height??c.height,g=b.output;if(s||((t=(s=q.e.get().createCanvas(256,128)).getContext("2d",{willReadFrequently:!0})).globalCompositeOperation="copy",t.globalAlpha=1),(s.width<e||s.height<f)&&(s.width=(0,r.U5)(e),s.height=(0,r.U5)(f)),!t)throw TypeError("Failed to get canvas 2D context");t.drawImage(c,0,0,e,f,0,0,e*d,f*d);let h=t.getImageData(0,0,e,f).data,i=0,j=0,k=e-1,l=f-1;for(;j<f&&u(h,e,j);)++j;if(j===f)return o.M.EMPTY;for(;u(h,e,l);)--l;for(;v(h,e,i,j,l);)++i;for(;v(h,e,k,j,l);)--k;return++k,++l,t.globalCompositeOperation="source-over",t.strokeRect(i,j,k-i,l-j),t.globalCompositeOperation="copy",g??(g=new o.M),g.set(i/d,j/d,(k-i)/d,(l-j)/d),g}({canvas:i.canvas,width:g,height:h,resolution:1,output:z}):z.set(0,0,g,h);return{canvasAndContext:i,frame:j}}returnCanvasAndContext(a){p.N.returnCanvasAndContext(a)}_renderTextToCanvas(a,b,c,d,e){let f,g,{canvas:h,context:i}=e,j=(0,x.Z)(b),k=w.P.measureText(a||" ",b),l=k.lines,m=k.lineHeight,o=k.lineWidths,p=k.maxLineWidth,q=k.fontProperties,r=h.height;if(i.resetTransform(),i.scale(d,d),i.textBaseline=b.textBaseline,b._stroke?.width){let a=b._stroke;i.lineWidth=a.width,i.miterLimit=a.miterLimit,i.lineJoin=a.join,i.lineCap=a.cap}i.font=j;let s=b.dropShadow?2:1;for(let a=0;a<s;++a){let h=b.dropShadow&&0===a,j=h?Math.ceil(Math.max(1,r)+2*c):0,s=j*d;if(h){i.fillStyle="black",i.strokeStyle="black";let a=b.dropShadow,c=a.color,e=a.alpha;i.shadowColor=n.Q.shared.setValue(c).setAlpha(e).toRgbaString();let f=a.blur*d,g=a.distance*d;i.shadowBlur=f,i.shadowOffsetX=Math.cos(a.angle)*g,i.shadowOffsetY=Math.sin(a.angle)*g+s}else{if(i.fillStyle=b._fill?(0,y.r)(b._fill,i,k,2*c):null,b._stroke?.width){let a=.5*b._stroke.width+2*c;i.strokeStyle=(0,y.r)(b._stroke,i,k,a)}i.shadowColor="black"}let t=(m-q.fontSize)/2;m-q.fontSize<0&&(t=0);let u=b._stroke?.width??0;for(let a=0;a<l.length;a++)f=u/2,g=u/2+a*m+q.ascent+t,"right"===b.align?f+=p-o[a]:"center"===b.align&&(f+=(p-o[a])/2),b._stroke?.width&&this._drawLetterSpacing(l[a],b,e,f+c,g+c-j,!0),void 0!==b._fill&&this._drawLetterSpacing(l[a],b,e,f+c,g+c-j)}}_drawLetterSpacing(a,b,c,d,e,f=!1){let{context:g}=c,h=b.letterSpacing,i=!1;if(w.P.experimentalLetterSpacingSupported&&(w.P.experimentalLetterSpacing?(g.letterSpacing=`${h}px`,g.textLetterSpacing=`${h}px`,i=!0):(g.letterSpacing="0px",g.textLetterSpacing="0px")),0===h||i)return void(f?g.strokeText(a,d,e):g.fillText(a,d,e));let j=d,k=w.P.graphemeSegmenter(a),l=g.measureText(a).width,m=0;for(let a=0;a<k.length;++a){let b=k[a];f?g.strokeText(b,j,e):g.fillText(b,j,e);let c="";for(let b=a+1;b<k.length;++b)c+=k[b];j+=l-(m=g.measureText(c).width)+h,l=m}}}let B=new A;class C{constructor(a){this._activeTextures={},this._renderer=a}getTexture(a,b,c,d){"string"==typeof a&&((0,k.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),a={text:a,style:c,resolution:b}),a.style instanceof l.x||(a.style=new l.x(a.style)),a.textureStyle instanceof j.n||(a.textureStyle=new j.n(a.textureStyle)),"string"!=typeof a.text&&(a.text=a.text.toString());let{text:e,style:f,textureStyle:g}=a,h=a.resolution??this._renderer.resolution,{frame:i,canvasAndContext:n}=B.getCanvasAndContext({text:e,style:f,resolution:h}),o=(0,m.M)(n.canvas,i.width,i.height,h);if(g&&(o.source.style=g),f.trim&&(i.pad(f.padding),o.frame.copyFrom(i),o.frame.scale(1/h),o.updateUvs()),f.filters){let a=this._applyFilters(o,f.filters);return this.returnTexture(o),B.returnCanvasAndContext(n),a}return this._renderer.texture.initSource(o._source),B.returnCanvasAndContext(n),o}returnTexture(a){let b=a.source;b.resource=null,b.uploadMethodId="unknown",b.alphaMode="no-premultiply-alpha",i.W.returnTexture(a,!0)}renderTextToCanvas(){(0,k.t6)("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(a){a._resolution=a._autoResolution?this._renderer.resolution:a.resolution;let b=a.styleKey;if(this._activeTextures[b])return this._increaseReferenceCount(b),this._activeTextures[b].texture;let c=this.getTexture({text:a.text,style:a.style,resolution:a._resolution,textureStyle:a.textureStyle});return this._activeTextures[b]={texture:c,usageCount:1},c}decreaseReferenceCount(a){let b=this._activeTextures[a];b.usageCount--,0===b.usageCount&&(this.returnTexture(b.texture),this._activeTextures[a]=null)}getReferenceCount(a){return this._activeTextures[a]?.usageCount??0}_increaseReferenceCount(a){this._activeTextures[a].usageCount++}_applyFilters(a,b){let c=this._renderer.renderTarget.renderTarget,d=this._renderer.filter.generateFilteredTexture({texture:a,filters:b});return this._renderer.renderTarget.bind(c,!1),d}destroy(){for(let a in this._renderer=null,this._activeTextures)this._activeTextures[a]&&this.returnTexture(this._activeTextures[a].texture);this._activeTextures=null}}C.extension={type:[d.Ag.WebGLSystem,d.Ag.WebGPUSystem,d.Ag.CanvasSystem],name:"canvasText"},d.XO.add(C),d.XO.add(h)}};