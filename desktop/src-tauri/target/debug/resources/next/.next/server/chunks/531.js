"use strict";exports.id=531,exports.ids=[531],exports.modules={22531:(a,b,c)=>{c.d(b,{WebGPURenderer:()=>ay});var d=c(45753),e=c(48419),f=c(21579),g=c(95420),h=c(80225),i=c(79862),j=c(14333),k=c(35563),l=c(86233),m=c(87796);class n{constructor(){this._maxTextures=0}contextChange(a){let b=new m.k({uTransformMatrix:{value:new e.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}});this._maxTextures=a.limits.maxBatchableTextures;let c=(0,g.v)({name:"graphics",bits:[h.F,(0,i._)(this._maxTextures),j._Q,k.b]});this.shader=new l.M({gpuProgram:c,resources:{localUniforms:b}})}execute(a,b){let c=b.context,d=c.customShader||this.shader,e=a.renderer,{batcher:g,instructions:h}=e.graphicsContext.getContextRenderData(c),i=e.encoder;i.setGeometry(g.geometry,d.gpuProgram);let j=e.globalUniforms.bindGroup;i.setBindGroup(0,j,d.gpuProgram);let k=e.renderPipes.uniformBatch.getUniformBindGroup(d.resources.localUniforms,!0);i.setBindGroup(2,k,d.gpuProgram);let l=h.instructions,m=null;for(let b=0;b<h.instructionSize;b++){let c=l[b];if(c.topology!==m&&(m=c.topology,i.setPipelineFromGeometryProgramAndState(g.geometry,d.gpuProgram,a.state,c.topology)),d.groups[1]=c.bindGroup,!c.gpuBindGroup){let a=c.textures;c.bindGroup=(0,f.w)(a.textures,a.count,this._maxTextures),c.gpuBindGroup=e.bindGroup.getBindGroup(c.bindGroup,d.gpuProgram,1)}i.setBindGroup(1,c.bindGroup,d.gpuProgram),i.renderPassEncoder.drawIndexed(c.size,1,c.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}n.extension={type:[d.Ag.WebGPUPipesAdaptor],name:"graphics"};var o=c(68689),p=c(61487),q=c(87818);class r{init(){let a=(0,g.v)({name:"mesh",bits:[j.Ls,o.R,k.b]});this._shader=new l.M({gpuProgram:a,resources:{uTexture:p.g.EMPTY._source,uSampler:p.g.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new e.u}}}})}execute(a,b){let c=a.renderer,d=b._shader;if(d){if(!d.gpuProgram)return void(0,q.R)("Mesh shader has no gpuProgram",b.shader)}else(d=this._shader).groups[2]=c.texture.getTextureBindGroup(b.texture);let e=d.gpuProgram;if(e.autoAssignGlobalUniforms&&(d.groups[0]=c.globalUniforms.bindGroup),e.autoAssignLocalUniforms){let b=a.localUniforms;d.groups[1]=c.renderPipes.uniformBatch.getUniformBindGroup(b,!0)}c.encoder.draw({geometry:b._geometry,shader:d,state:b.state})}destroy(){this._shader.destroy(!0),this._shader=null}}r.extension={type:[d.Ag.WebGPUPipesAdaptor],name:"mesh"};var s=c(83305);let t=s.U.for2d();class u{start(a,b,c){let d=a.renderer,e=d.encoder,f=c.gpuProgram;this._shader=c,this._geometry=b,e.setGeometry(b,f),t.blendMode="normal",d.pipeline.getPipeline(b,f,t);let g=d.globalUniforms.bindGroup;e.resetBindGroup(1),e.setBindGroup(0,g,f)}execute(a,b){let c=this._shader.gpuProgram,d=a.renderer,e=d.encoder;if(!b.bindGroup){let a=b.textures;b.bindGroup=(0,f.w)(a.textures,a.count,d.limits.maxBatchableTextures)}t.blendMode=b.blendMode;let g=d.bindGroup.getBindGroup(b.bindGroup,c,1),h=d.pipeline.getPipeline(this._geometry,c,t,b.topology);b.bindGroup._touch(d.textureGC.count),e.setPipeline(h),e.renderPassEncoder.setBindGroup(1,g),e.renderPassEncoder.drawIndexed(b.size,1,b.start)}}u.extension={type:[d.Ag.WebGPUPipesAdaptor],name:"batch"};var v=c(15629),w=c(9563),x=c(11489);class y{constructor(a){this._hash=Object.create(null),this._renderer=a,this._renderer.renderableGC.addManagedHash(this,"_hash")}contextChange(a){this._gpu=a}getBindGroup(a,b,c){return a._updateKey(),this._hash[a._key]||this._createBindGroup(a,b,c)}_createBindGroup(a,b,c){let d=this._gpu.device,e=b.layout[c],f=[],g=this._renderer;for(let b in e){let c,d=a.resources[b]??a.resources[e[b]];if("uniformGroup"===d._resourceType){g.ubo.updateUniformGroup(d);let a=d.buffer;c={buffer:g.buffer.getGPUBuffer(a),offset:0,size:a.descriptor.size}}else"buffer"===d._resourceType?c={buffer:g.buffer.getGPUBuffer(d),offset:0,size:d.descriptor.size}:"bufferResource"===d._resourceType?c={buffer:g.buffer.getGPUBuffer(d.buffer),offset:d.offset,size:d.size}:"textureSampler"===d._resourceType?c=g.texture.getGpuSampler(d):"textureSource"===d._resourceType&&(c=g.texture.getGpuSource(d).createView({}));f.push({binding:e[b],resource:c})}let h=g.shader.getProgramData(b).bindGroups[c],i=d.createBindGroup({layout:h,entries:f});return this._hash[a._key]=i,i}destroy(){for(let a of Object.keys(this._hash))this._hash[a]=null;this._hash=null,this._renderer=null}}y.extension={type:[d.Ag.WebGPUSystem],name:"bindGroup"};var z=c(41090);class A{constructor(a){this._gpuBuffers=Object.create(null),a.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(a){this._gpu=a}getGPUBuffer(a){return this._gpuBuffers[a.uid]||this.createGPUBuffer(a)}updateBuffer(a){let b=this._gpuBuffers[a.uid]||this.createGPUBuffer(a),c=a.data;return a._updateID&&c&&(a._updateID=0,this._gpu.device.queue.writeBuffer(b,0,c.buffer,0,(a._updateSize||c.byteLength)+3&-4)),b}destroyAll(){for(let a in this._gpuBuffers)this._gpuBuffers[a]?.destroy();this._gpuBuffers={}}createGPUBuffer(a){this._gpuBuffers[a.uid]||(a.on("update",this.updateBuffer,this),a.on("change",this.onBufferChange,this),a.on("destroy",this.onBufferDestroy,this));let b=this._gpu.device.createBuffer(a.descriptor);return a._updateID=0,a.data&&((0,z.W)(a.data.buffer,b.getMappedRange()),b.unmap()),this._gpuBuffers[a.uid]=b,b}onBufferChange(a){this._gpuBuffers[a.uid].destroy(),a._updateID=0,this._gpuBuffers[a.uid]=this.createGPUBuffer(a)}onBufferDestroy(a){this._destroyBuffer(a)}destroy(){this.destroyAll(),this._gpuBuffers={}}_destroyBuffer(a){a.off("update",this.updateBuffer,this),a.off("change",this.onBufferChange,this),a.off("destroy",this.onBufferDestroy,this),this._gpuBuffers[a.uid]&&(this._gpuBuffers[a.uid].destroy(),this._gpuBuffers[a.uid]=null)}}A.extension={type:[d.Ag.WebGPUSystem],name:"buffer"};class B{constructor(a){this._colorMaskCache=15,this._renderer=a}setMask(a){this._colorMaskCache!==a&&(this._colorMaskCache=a,this._renderer.pipeline.setColorMask(a))}destroy(){this._renderer=null,this._colorMaskCache=null}}B.extension={type:[d.Ag.WebGPUSystem],name:"colorMask"};var C=c(43274);class D{constructor(a){this._renderer=a}async init(a){return this._initPromise||(this._initPromise=(a.gpu?Promise.resolve(a.gpu):this._createDeviceAndAdaptor(a)).then(a=>{this.gpu=a,this._renderer.runners.contextChange.emit(this.gpu)})),this._initPromise}contextChange(a){this._renderer.gpu=a}async _createDeviceAndAdaptor(a){let b=await C.e.get().getNavigator().gpu.requestAdapter({powerPreference:a.powerPreference,forceFallbackAdapter:a.forceFallbackAdapter}),c=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(a=>b.features.has(a)),d=await b.requestDevice({requiredFeatures:c});return{adapter:b,device:d}}destroy(){this.gpu=null,this._renderer=null}}D.extension={type:[d.Ag.WebGPUSystem],name:"device"},D.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class E{constructor(a){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=a}renderStart(){this.commandFinished=new Promise(a=>{this._resolveCommandFinished=a}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(a){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(a.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(a){this.renderPassEncoder.setViewport(a.x,a.y,a.width,a.height,0,1)}setPipelineFromGeometryProgramAndState(a,b,c,d){let e=this._renderer.pipeline.getPipeline(a,b,c,d);this.setPipeline(e)}setPipeline(a){this._boundPipeline!==a&&(this._boundPipeline=a,this.renderPassEncoder.setPipeline(a))}_setVertexBuffer(a,b){this._boundVertexBuffer[a]!==b&&(this._boundVertexBuffer[a]=b,this.renderPassEncoder.setVertexBuffer(a,this._renderer.buffer.updateBuffer(b)))}_setIndexBuffer(a){if(this._boundIndexBuffer===a)return;this._boundIndexBuffer=a;let b=2===a.data.BYTES_PER_ELEMENT?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(a),b)}resetBindGroup(a){this._boundBindGroup[a]=null}setBindGroup(a,b,c){if(this._boundBindGroup[a]===b)return;this._boundBindGroup[a]=b,b._touch(this._renderer.textureGC.count);let d=this._renderer.bindGroup.getBindGroup(b,c,a);this.renderPassEncoder.setBindGroup(a,d)}setGeometry(a,b){let c=this._renderer.pipeline.getBufferNamesToBind(a,b);for(let b in c)this._setVertexBuffer(parseInt(b,10),a.attributes[c[b]].buffer);a.indexBuffer&&this._setIndexBuffer(a.indexBuffer)}_setShaderBindGroups(a,b){for(let c in a.groups){let d=a.groups[c];b||this._syncBindGroup(d),this.setBindGroup(c,d,a.gpuProgram)}}_syncBindGroup(a){for(let b in a.resources){let c=a.resources[b];c.isUniformGroup&&this._renderer.ubo.updateUniformGroup(c)}}draw(a){let{geometry:b,shader:c,state:d,topology:e,size:f,start:g,instanceCount:h,skipSync:i}=a;this.setPipelineFromGeometryProgramAndState(b,c.gpuProgram,d,e),this.setGeometry(b,c.gpuProgram),this._setShaderBindGroups(c,i),b.indexBuffer?this.renderPassEncoder.drawIndexed(f||b.indexBuffer.data.length,h??b.instanceCount,g||0):this.renderPassEncoder.draw(f||b.getSize(),h??b.instanceCount,g||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){let a=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(a);let b=this._boundPipeline,c={...this._boundVertexBuffer},d=this._boundIndexBuffer,e={...this._boundBindGroup};this._clearCache();let f=this._renderer.renderTarget.viewport;for(let a in this.renderPassEncoder.setViewport(f.x,f.y,f.width,f.height,0,1),this.setPipeline(b),c)this._setVertexBuffer(a,c[a]);for(let a in e)this.setBindGroup(a,e[a],null);this._setIndexBuffer(d)}_clearCache(){for(let a=0;a<16;a++)this._boundBindGroup[a]=null,this._boundVertexBuffer[a]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(a){this._gpu=a}}E.extension={type:[d.Ag.WebGPUSystem],name:"encoder",priority:1};class F{constructor(a){this._renderer=a}contextChange(){this.maxTextures=this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,this.maxBatchableTextures=this.maxTextures}destroy(){}}F.extension={type:[d.Ag.WebGPUSystem],name:"limits"};var G=c(21507);class H{constructor(a){this._renderTargetStencilState=Object.create(null),this._renderer=a,a.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(a){let b=this._renderTargetStencilState[a.uid];b||(b=this._renderTargetStencilState[a.uid]={stencilMode:G.K.DISABLED,stencilReference:0}),this._activeRenderTarget=a,this.setStencilMode(b.stencilMode,b.stencilReference)}setStencilMode(a,b){let c=this._renderTargetStencilState[this._activeRenderTarget.uid];c.stencilMode=a,c.stencilReference=b;let d=this._renderer;d.pipeline.setStencilMode(a),d.encoder.renderPassEncoder.setStencilReference(b)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}H.extension={type:[d.Ag.WebGPUSystem],name:"stencil"};var I=c(47745);let J={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function K(a){let b=a.map(a=>({data:a,offset:0,size:0})),c=0;for(let a=0;a<b.length;a++){let d=b[a],e=J[d.data.type].size,f=J[d.data.type].align;if(!J[d.data.type])throw Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${d.data.type}`);d.data.size>1&&(e=Math.max(e,f)*d.data.size),c=Math.ceil(c/f)*f,d.size=e,d.offset=c,c+=e}return{uboElements:b,size:c=16*Math.ceil(c/16)}}var L=c(3009),M=c(85612);function N(a,b){let{size:c,align:d}=J[a.data.type],e=(d-c)/4,f=a.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
         v = uv.${a.data.name};
         ${0!==b?`offset += ${b};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${a.data.size*(c/4)}; i++)
         {
             for(var j = 0; j < ${c/4}; j++)
             {
                 ${f}[arrayOffset++] = v[t++];
             }
             ${0!==e?`arrayOffset += ${e};`:""}
         }
     `}function O(a){return(0,L.E)(a,"uboWgsl",N,M._)}class P extends I.W{constructor(){super({createUboElements:K,generateUboSync:O})}}P.extension={type:[d.Ag.WebGPUSystem],name:"ubo"};var Q=c(16183),R=c(86128),S=c(43362);class T{constructor({minUniformOffsetAlignment:a}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=a,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(a){if(a>this._minUniformOffsetAlignment/4)throw Error(`UniformBufferBatch: array is too large: ${4*a}`);let b=this.byteIndex,c=b+4*a;if((c=Math.ceil(c/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment)>4*this.data.length)throw Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=c,b}addGroup(a){let b=this.addEmptyGroup(a.length);for(let c=0;c<a.length;c++)this.data[b/4+c]=a[c];return b}destroy(){this.data=null}}var U=c(19979);class V{constructor(a){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=a,this._renderer.renderableGC.addManagedHash(this,"_bindGroupHash"),this._batchBuffer=new T({minUniformOffsetAlignment:128});for(let a=0;a<2;a++){let b=S.S.UNIFORM|S.S.COPY_DST;0===a&&(b|=S.S.COPY_SRC),this._buffers.push(new Q.h({data:this._batchBuffer.data,usage:b}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(let a in this._bindGroupHash)this._bindGroupHash[a]=null;this._batchBuffer.clear()}getUniformBindGroup(a,b){if(!b&&this._bindGroupHash[a.uid])return this._bindGroupHash[a.uid];this._renderer.ubo.ensureUniformGroup(a);let c=a.buffer.data,d=this._batchBuffer.addEmptyGroup(c.length);return this._renderer.ubo.syncUniformGroup(a,this._batchBuffer.data,d/4),this._bindGroupHash[a.uid]=this._getBindGroup(d/128),this._bindGroupHash[a.uid]}getUboResource(a){this._renderer.ubo.updateUniformGroup(a);let b=a.buffer.data,c=this._batchBuffer.addGroup(b);return this._getBufferResource(c/128)}getArrayBindGroup(a){let b=this._batchBuffer.addGroup(a);return this._getBindGroup(b/128)}getArrayBufferResource(a){let b=this._batchBuffer.addGroup(a);return this._getBufferResource(b/128)}_getBufferResource(a){if(!this._bufferResources[a]){let b=this._buffers[a%2];this._bufferResources[a]=new R.d({buffer:b,offset:(a/2|0)*256,size:128})}return this._bufferResources[a]}_getBindGroup(a){if(!this._bindGroups[a]){let b=new U.T({0:this._getBufferResource(a)});this._bindGroups[a]=b}return this._bindGroups[a]}_uploadBindGroups(){let a=this._renderer.buffer,b=this._buffers[0];b.update(this._batchBuffer.byteIndex),a.updateBuffer(b);let c=this._renderer.gpu.device.createCommandEncoder();for(let d=1;d<this._buffers.length;d++){let e=this._buffers[d];c.copyBufferToBuffer(a.getGPUBuffer(b),128,a.getGPUBuffer(e),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([c.finish()])}destroy(){for(let a=0;a<this._bindGroups.length;a++)this._bindGroups[a]?.destroy();this._bindGroups=null,this._bindGroupHash=null;for(let a=0;a<this._buffers.length;a++)this._buffers[a].destroy();this._buffers=null;for(let a=0;a<this._bufferResources.length;a++)this._bufferResources[a].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}V.extension={type:[d.Ag.WebGPUPipes],name:"uniformBatch"};var W=c(80326),X=c(48873),Y=c(77894);let Z={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};class ${constructor(a){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=a}contextChange(a){this._gpu=a,this.setStencilMode(G.K.DISABLED),this._updatePipeHash()}setMultisampleCount(a){this._multisampleCount!==a&&(this._multisampleCount=a,this._updatePipeHash())}setRenderTarget(a){this._multisampleCount=a.msaaSamples,this._depthStencilAttachment=+!!a.descriptor.depthStencilAttachment,this._updatePipeHash()}setColorMask(a){this._colorMask!==a&&(this._colorMask=a,this._updatePipeHash())}setStencilMode(a){this._stencilMode!==a&&(this._stencilMode=a,this._stencilState=Y.g[a],this._updatePipeHash())}setPipeline(a,b,c,d){let e=this.getPipeline(a,b,c);d.setPipeline(e)}getPipeline(a,b,c,d){var e,f,g;a._layoutKey||((0,W.q)(a,b.attributeData),this._generateBufferKey(a)),d||(d=a.topology);let h=(e=a._layoutKey,f=b._layoutKey,g=c.data,e<<24|f<<16|g<<10|c._blendModeId<<5|Z[d]);return this._pipeCache[h]||(this._pipeCache[h]=this._createPipeline(a,b,c,d)),this._pipeCache[h]}_createPipeline(a,b,c,d){let e=this._gpu.device,f=this._createVertexBufferLayouts(a,b),g=this._renderer.state.getColorTargets(c);g[0].writeMask=this._stencilMode===G.K.RENDERING_MASK_ADD?0:this._colorMask;let h=this._renderer.shader.getProgramData(b).pipeline,i={vertex:{module:this._getModule(b.vertex.source),entryPoint:b.vertex.entryPoint,buffers:f},fragment:{module:this._getModule(b.fragment.source),entryPoint:b.fragment.entryPoint,targets:g},primitive:{topology:d,cullMode:c.cullMode},layout:h,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(i.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:c.depthTest,depthCompare:c.depthTest?"less":"always"}),e.createRenderPipeline(i)}_getModule(a){return this._moduleCache[a]||this._createModule(a)}_createModule(a){let b=this._gpu.device;return this._moduleCache[a]=b.createShaderModule({code:a}),this._moduleCache[a]}_generateBufferKey(a){let b=[],c=0,d=Object.keys(a.attributes).sort();for(let e=0;e<d.length;e++){let f=a.attributes[d[e]];b[c++]=f.offset,b[c++]=f.format,b[c++]=f.stride,b[c++]=f.instance}let e=b.join("|");return a._layoutKey=(0,X.X)(e,"geometry"),a._layoutKey}_generateAttributeLocationsKey(a){let b=[],c=0,d=Object.keys(a.attributeData).sort();for(let e=0;e<d.length;e++){let f=a.attributeData[d[e]];b[c++]=f.location}let e=b.join("|");return a._attributeLocationsKey=(0,X.X)(e,"programAttributes"),a._attributeLocationsKey}getBufferNamesToBind(a,b){let c=a._layoutKey<<16|b._attributeLocationsKey;if(this._bindingNamesCache[c])return this._bindingNamesCache[c];let d=this._createVertexBufferLayouts(a,b),e=Object.create(null),f=b.attributeData;for(let a=0;a<d.length;a++){let b=Object.values(d[a].attributes)[0].shaderLocation;for(let c in f)if(f[c].location===b){e[a]=c;break}}return this._bindingNamesCache[c]=e,e}_createVertexBufferLayouts(a,b){b._attributeLocationsKey||this._generateAttributeLocationsKey(b);let c=a._layoutKey<<16|b._attributeLocationsKey;if(this._bufferLayoutsCache[c])return this._bufferLayoutsCache[c];let d=[];return a.buffers.forEach(c=>{let e={arrayStride:0,stepMode:"vertex",attributes:[]},f=e.attributes;for(let d in b.attributeData){let g=a.attributes[d];(g.divisor??1)!==1&&(0,q.R)(`Attribute ${d} has an invalid divisor value of '${g.divisor}'. WebGPU only supports a divisor value of 1`),g.buffer===c&&(e.arrayStride=g.stride,e.stepMode=g.instance?"instance":"vertex",f.push({shaderLocation:b.attributeData[d].location,offset:g.offset,format:g.format}))}f.length&&d.push(e)}),this._bufferLayoutsCache[c]=d,d}_updatePipeHash(){var a,b;let c=(a=this._stencilMode,b=this._multisampleCount,this._colorMask<<6|a<<3|this._depthStencilAttachment<<1|b);this._pipeStateCaches[c]||(this._pipeStateCaches[c]=Object.create(null)),this._pipeCache=this._pipeStateCaches[c]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}$.extension={type:[d.Ag.WebGPUSystem],name:"pipeline"};var _=c(2433),aa=c(69043),ab=c(1342),ac=c(93141);class ad{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class ae{init(a,b){this._renderer=a,this._renderTargetSystem=b}copyToTexture(a,b,c,d,e){let f=this._renderer,g=this._getGpuColorTexture(a),h=f.texture.getGpuSource(b.source);return f.encoder.commandEncoder.copyTextureToTexture({texture:g,origin:c},{texture:h,origin:e},d),b}startRenderPass(a,b=!0,c,d){let e=this._renderTargetSystem.getGpuRenderTarget(a);e.descriptor=this.getDescriptor(a,b,c),this._renderer.pipeline.setRenderTarget(e),this._renderer.encoder.beginRenderPass(e),this._renderer.encoder.setViewport(d)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(a){let b=this._renderTargetSystem.getGpuRenderTarget(a);return b.contexts[0]?b.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(a.colorTextures[0].source)}getDescriptor(a,b,c){let d;"boolean"==typeof b&&(b=b?aa.u.ALL:aa.u.NONE);let e=this._renderTargetSystem,f=e.getGpuRenderTarget(a),g=a.colorTextures.map((a,d)=>{let g,h,i=f.contexts[d];g=i?i.getCurrentTexture().createView():this._renderer.texture.getGpuSource(a).createView({mipLevelCount:1}),f.msaaTextures[d]&&(h=g,g=this._renderer.texture.getTextureView(f.msaaTextures[d]));let j=b&aa.u.COLOR?"clear":"load";return c??(c=e.defaultClearColor),{view:g,resolveTarget:h,clearValue:c,storeOp:"store",loadOp:j}});if((a.stencil||a.depth)&&!a.depthStencilTexture&&(a.ensureDepthStencilTexture(),a.depthStencilTexture.source.sampleCount=f.msaa?4:1),a.depthStencilTexture){let c=b&aa.u.STENCIL?"clear":"load",e=b&aa.u.DEPTH?"clear":"load";d={view:this._renderer.texture.getGpuSource(a.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:c,depthClearValue:1,depthLoadOp:e,depthStoreOp:"store"}}return{colorAttachments:g,depthStencilAttachment:d}}clear(a,b=!0,c,d){if(!b)return;let{gpu:e,encoder:f}=this._renderer,g=e.device;if(null===f.commandEncoder){let e=g.createCommandEncoder(),f=this.getDescriptor(a,b,c),h=e.beginRenderPass(f);h.setViewport(d.x,d.y,d.width,d.height,0,1),h.end();let i=e.finish();g.queue.submit([i])}else this.startRenderPass(a,b,c,d)}initGpuRenderTarget(a){a.isRoot=!0;let b=new ad;return a.colorTextures.forEach((a,c)=>{if(a instanceof ab.q){let d=a.resource.getContext("webgpu"),e=a.transparent?"premultiplied":"opaque";try{d.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:e})}catch(a){console.error(a)}b.contexts[c]=d}if(b.msaa=a.source.antialias,a.source.antialias){let a=new ac.v({width:0,height:0,sampleCount:4});b.msaaTextures[c]=a}}),b.msaa&&(b.msaaSamples=4,a.depthStencilTexture&&(a.depthStencilTexture.source.sampleCount=4)),b}destroyGpuRenderTarget(a){a.contexts.forEach(a=>{a.unconfigure()}),a.msaaTextures.forEach(a=>{a.destroy()}),a.msaaTextures.length=0,a.contexts.length=0}ensureDepthStencilTexture(a){let b=this._renderTargetSystem.getGpuRenderTarget(a);a.depthStencilTexture&&b.msaa&&(a.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(a){let b=this._renderTargetSystem.getGpuRenderTarget(a);b.width=a.width,b.height=a.height,b.msaa&&a.colorTextures.forEach((a,c)=>{let d=b.msaaTextures[c];d?.resize(a.source.width,a.source.height,a.source._resolution)})}}class af extends _.l{constructor(a){super(a),this.adaptor=new ae,this.adaptor.init(a,this)}}af.extension={type:[d.Ag.WebGPUSystem],name:"renderTarget"};class ag{constructor(){this._gpuProgramData=Object.create(null)}contextChange(a){this._gpu=a}getProgramData(a){return this._gpuProgramData[a._layoutKey]||this._createGPUProgramData(a)}_createGPUProgramData(a){let b=this._gpu.device,c=a.gpuLayout.map(a=>b.createBindGroupLayout({entries:a}));return this._gpuProgramData[a._layoutKey]={bindGroups:c,pipeline:b.createPipelineLayout({bindGroupLayouts:c})},this._gpuProgramData[a._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}ag.extension={type:[d.Ag.WebGPUSystem],name:"shader"};let ah={};ah.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},ah.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},ah.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},ah.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},ah.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},ah.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},ah["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},ah["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},ah["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},ah.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}},ah.min={alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}},ah.max={alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}};class ai{constructor(){this.defaultState=new s.U,this.defaultState.blend=!0}contextChange(a){this.gpu=a}getColorTargets(a){return[{format:"bgra8unorm",writeMask:0,blend:ah[a.blendMode]||ah.normal}]}destroy(){this.gpu=null}}ai.extension={type:[d.Ag.WebGPUSystem],name:"state"};var aj=c(92714);let ak={type:"image",upload(a,b,c){let d=a.resource,e=(0|a.pixelWidth)*(0|a.pixelHeight),f=d.byteLength/e;c.device.queue.writeTexture({texture:b},d,{offset:0,rowsPerImage:a.pixelHeight,bytesPerRow:a.pixelWidth*f},{width:a.pixelWidth,height:a.pixelHeight,depthOrArrayLayers:1})}},al={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},am={blockBytes:4,blockWidth:1,blockHeight:1},an={type:"compressed",upload(a,b,c){let d=a.pixelWidth,e=a.pixelHeight,f=al[a.format]||am;for(let g=0;g<a.resource.length;g++){let h=a.resource[g],i=Math.ceil(d/f.blockWidth)*f.blockBytes;c.device.queue.writeTexture({texture:b,mipLevel:g},h,{offset:0,bytesPerRow:i},{width:Math.ceil(d/f.blockWidth)*f.blockWidth,height:Math.ceil(e/f.blockHeight)*f.blockHeight,depthOrArrayLayers:1}),d=Math.max(d>>1,1),e=Math.max(e>>1,1)}}},ao={type:"image",upload(a,b,c){let d=a.resource;if(!d)return;if(globalThis.HTMLImageElement&&d instanceof HTMLImageElement){let b=C.e.get().createCanvas(d.width,d.height);b.getContext("2d").drawImage(d,0,0,d.width,d.height),a.resource=b,(0,q.R)("ImageSource: Image element passed, converting to canvas and replacing resource.")}let e=Math.min(b.width,a.resourceWidth||a.pixelWidth),f=Math.min(b.height,a.resourceHeight||a.pixelHeight),g="premultiply-alpha-on-upload"===a.alphaMode;c.device.queue.copyExternalImageToTexture({source:d},{texture:b,premultipliedAlpha:g},{width:e,height:f})}},ap={type:"video",upload(a,b,c){ao.upload(a,b,c)}};class aq{constructor(a){this.device=a,this.sampler=a.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(a){let b=this.pipelines[a];return b||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),b=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:a}]}}),this.pipelines[a]=b),b}generateMipmap(a){let b=this._getMipmapPipeline(a.format);if("3d"===a.dimension||"1d"===a.dimension)throw Error("Generating mipmaps for non-2d textures is currently unsupported!");let c=a,d=a.depthOrArrayLayers||1,e=a.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!e){let b={size:{width:Math.ceil(a.width/2),height:Math.ceil(a.height/2),depthOrArrayLayers:d},format:a.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:a.mipLevelCount-1};c=this.device.createTexture(b)}let f=this.device.createCommandEncoder({}),g=b.getBindGroupLayout(0);for(let h=0;h<d;++h){let d=a.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:h,arrayLayerCount:1}),i=+!!e;for(let e=1;e<a.mipLevelCount;++e){let a=c.createView({baseMipLevel:i++,mipLevelCount:1,dimension:"2d",baseArrayLayer:h,arrayLayerCount:1}),e=f.beginRenderPass({colorAttachments:[{view:a,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),j=this.device.createBindGroup({layout:g,entries:[{binding:0,resource:this.sampler},{binding:1,resource:d}]});e.setPipeline(b),e.setBindGroup(0,j),e.draw(3,1,0,0),e.end(),d=a}}if(!e){let b={width:Math.ceil(a.width/2),height:Math.ceil(a.height/2),depthOrArrayLayers:d};for(let d=1;d<a.mipLevelCount;++d)f.copyTextureToTexture({texture:c,mipLevel:d-1},{texture:a,mipLevel:d},b),b.width=Math.ceil(b.width/2),b.height=Math.ceil(b.height/2)}return this.device.queue.submit([f.finish()]),e||c.destroy(),a}}class ar{constructor(a){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:ao,buffer:ak,video:ap,compressed:an},this._renderer=a,a.renderableGC.addManagedHash(this,"_gpuSources"),a.renderableGC.addManagedHash(this,"_gpuSamplers"),a.renderableGC.addManagedHash(this,"_bindGroupHash"),a.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(a){this._gpu=a}initSource(a){return this._gpuSources[a.uid]?this._gpuSources[a.uid]:this._initSource(a)}_initSource(a){if(a.autoGenerateMipmaps){let b=Math.max(a.pixelWidth,a.pixelHeight);a.mipLevelCount=Math.floor(Math.log2(b))+1}let b=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;"compressed"!==a.uploadMethodId&&(b|=GPUTextureUsage.RENDER_ATTACHMENT,b|=GPUTextureUsage.COPY_SRC);let c=al[a.format]||{blockBytes:4,blockWidth:1,blockHeight:1},d=Math.ceil(a.pixelWidth/c.blockWidth)*c.blockWidth,e=Math.ceil(a.pixelHeight/c.blockHeight)*c.blockHeight,f={label:a.label,size:{width:d,height:e},format:a.format,sampleCount:a.sampleCount,mipLevelCount:a.mipLevelCount,dimension:a.dimension,usage:b},g=this._gpuSources[a.uid]=this._gpu.device.createTexture(f);return this.managedTextures.includes(a)||(a.on("update",this.onSourceUpdate,this),a.on("resize",this.onSourceResize,this),a.on("destroy",this.onSourceDestroy,this),a.on("unload",this.onSourceUnload,this),a.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(a)),this.onSourceUpdate(a),g}onSourceUpdate(a){let b=this.getGpuSource(a);b&&(this._uploads[a.uploadMethodId]&&this._uploads[a.uploadMethodId].upload(a,b,this._gpu),a.autoGenerateMipmaps&&a.mipLevelCount>1&&this.onUpdateMipmaps(a))}onSourceUnload(a){let b=this._gpuSources[a.uid];b&&(this._gpuSources[a.uid]=null,b.destroy())}onUpdateMipmaps(a){this._mipmapGenerator||(this._mipmapGenerator=new aq(this._gpu.device));let b=this.getGpuSource(a);this._mipmapGenerator.generateMipmap(b)}onSourceDestroy(a){a.off("update",this.onSourceUpdate,this),a.off("unload",this.onSourceUnload,this),a.off("destroy",this.onSourceDestroy,this),a.off("resize",this.onSourceResize,this),a.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(a),1),this.onSourceUnload(a)}onSourceResize(a){let b=this._gpuSources[a.uid];b?(b.width!==a.pixelWidth||b.height!==a.pixelHeight)&&(this._textureViewHash[a.uid]=null,this._bindGroupHash[a.uid]=null,this.onSourceUnload(a),this.initSource(a)):this.initSource(a)}_initSampler(a){return this._gpuSamplers[a._resourceId]=this._gpu.device.createSampler(a),this._gpuSamplers[a._resourceId]}getGpuSampler(a){return this._gpuSamplers[a._resourceId]||this._initSampler(a)}getGpuSource(a){return this._gpuSources[a.uid]||this.initSource(a)}getTextureBindGroup(a){return this._bindGroupHash[a.uid]??this._createTextureBindGroup(a)}_createTextureBindGroup(a){let b=a.source;return this._bindGroupHash[a.uid]=new U.T({0:b,1:b.style,2:new m.k({uTextureMatrix:{type:"mat3x3<f32>",value:a.textureMatrix.mapCoord}})}),this._bindGroupHash[a.uid]}getTextureView(a){let b=a.source;return this._textureViewHash[b.uid]??this._createTextureView(b)}_createTextureView(a){return this._textureViewHash[a.uid]=this.getGpuSource(a).createView(),this._textureViewHash[a.uid]}generateCanvas(a){let b=this._renderer,c=b.gpu.device.createCommandEncoder(),d=C.e.get().createCanvas();d.width=a.source.pixelWidth,d.height=a.source.pixelHeight;let e=d.getContext("webgpu");return e.configure({device:b.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:C.e.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),c.copyTextureToTexture({texture:b.texture.getGpuSource(a.source),origin:{x:0,y:0}},{texture:e.getCurrentTexture()},{width:d.width,height:d.height}),b.gpu.device.queue.submit([c.finish()]),d}getPixels(a){let b=this.generateCanvas(a),c=aj.N.getOptimalCanvasAndContext(b.width,b.height),d=c.context;d.drawImage(b,0,0);let{width:e,height:f}=b,g=new Uint8ClampedArray(d.getImageData(0,0,e,f).data.buffer);return aj.N.returnCanvasAndContext(c),{pixels:g,width:e,height:f}}destroy(){for(let a of(this.managedTextures.slice().forEach(a=>this.onSourceDestroy(a)),this.managedTextures=null,Object.keys(this._bindGroupHash))){let b=Number(a),c=this._bindGroupHash[b];c?.destroy(),this._bindGroupHash[b]=null}this._renderer=null,this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}ar.extension={type:[d.Ag.WebGPUSystem],name:"texture"};let as=[...w.i,P,E,D,F,A,ar,af,ag,ai,$,B,H,y],at=[...w.f,V],au=[u,r,n],av=[],aw=[],ax=[];d.XO.handleByNamedList(d.Ag.WebGPUSystem,av),d.XO.handleByNamedList(d.Ag.WebGPUPipes,aw),d.XO.handleByNamedList(d.Ag.WebGPUPipesAdaptor,ax),d.XO.add(...as,...at,...au);class ay extends v.k{constructor(){super({name:"webgpu",type:x.W.WEBGPU,systems:av,renderPipes:aw,renderPipeAdaptors:ax})}}}};